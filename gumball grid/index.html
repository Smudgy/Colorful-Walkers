<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title></title>
  <style>
  canvas {
    position: absolute;
    top: 0;
    left: 0;
  }

  </style>

</head>

<body>
  <script src="js/p5.js"></script>
  <script src="js/varInit.js"></script>
  <script>

  // Dot class

  class Dot {
    constructor(x, y) {
      this.v1 = createVector(x, y);
      this.anchDist = createVector(w/2 - x, h/2 - y).mag();
    }

    show() {
      let v2 = createVector(mouseX - this.v1.x, mouseY - this.v1.y);
      let d = v2.mag();
      v2.normalize();

      let radius = Math.max( rad1 + (rad2 - rad1) * pow(map(d, 0, radd, 1.0, 0, true), radp), 0 );
      let roundoff = Math.max( ( rou1 + (rou2 - rou1) * pow(map(d, 0, roud, 1.0, 0, true), roup)) * radius / 200, 0 );
      let shift = sh1 + (sh2 - sh1) * pow(map(d, 0, shd, 1.0, 0, true), shp);
      let rotation = ( rot1 + rot2 * pow(map(d, 0, rotd, 1.0, 0, true), rotp) + rotLoop * frameCount ) % 360;

      let hue = ((( hue1 + (hue2 - hue1) * pow(map(d, 0, hued, 1.0, 0, true), huep) + hueLoop * frameCount ) % 360 ) + 360 ) % 360;
      let sat = sat1 + (sat2 - sat1) * pow(map(d, 0, satd, 1.0, 0, true), satp );
      let lum = lum1 + (lum2 - lum1) * pow(map(d, 0, lumd, 1.0, 0, true), lump );
      let alpha = a1 + (a2 - a1) * pow(map(d, 0, ad, 1.0, 0, true), ap);

      noStroke();

      push();
      colorMode(HSB);
      translate(this.v1.x - shift * v2.x, this.v1.y - shift * v2.y);
      rotate( rotation );
      fill( hue, sat, lum, alpha );
      rect(0, 0, radius, radius, roundoff);
      pop();
    }
  };

  // p5 setup() and draw()

  function setup() {
    createCanvas(w, h);
    angleMode(DEGREES);
    rectMode(CENTER);

    let shfBound = -Math.min(sh1, sh2);
    let xAlt = 0;
    if ( hex ) {
      let yAlt = n * sin(60);
      for ( let y = h/2 - Math.ceil((h / 2 + shfBound)/ yAlt) * yAlt; y < h + shfBound + yAlt; y += yAlt) {
        for ( let x = w/2 - Math.ceil((w / 2 + shfBound)/ n) * n - xAlt; x < w + shfBound + n; x += n ){
          dots.push(new Dot(x, y));
        }
        if ( xAlt == 0 ) {
          xAlt = n/2;
        } else {
          xAlt = 0;
        }
      }
    } else {
      let yAlt = n;
      for ( let y = h/2 - Math.ceil((h / 2 + shfBound)/ yAlt) * yAlt; y < h + shfBound + yAlt; y += yAlt) {
        for ( let x = w/2 - Math.ceil((w / 2 + shfBound)/ n) * n - xAlt; x < w + shfBound + n; x += n ){
          dots.push(new Dot(x, y));
        }
      }
    }

    // middle dot for debugging
    //dots.push(new Dot(w/2, h/2));
  }

  function draw() {
    push();
    colorMode(HSB);
    background(200, 30, 10);
    pop();

    for (let i = 0; i < dots.length; i++) {
      if ( dots[i].anchDist > circleMask / 2 ) {
        dots.splice(i,1);
      } else {
        dots[i].show();
      }
    }
  }

  // resize function

  window.addEventListener('resize', function() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
    dots = [];
    setup();
  })

  </script>
</body>

</html>
